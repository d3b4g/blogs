---
layout: post
title:  "x86-linux-exploit-development-introduction"
date:   2020-01-18 15:07:19
categories: [Binary Exploitation]
excerpt: "Welcome to part one of the x86 Linux binary exploitation series. In these series of posts, I will cover x86 Linux binary exploitation, from basics to advanced topics."
comments: true
---




**Introduction**  
Welcome to part one of the x86 Linux binary exploitation series. In these series of posts, I will cover x86 Linux binary exploitation, from basics to advanced topics.

All of the exercises in these articles can be done in a virtual environment. Tools that I will be using are: 

  * gef (GDB plugin): <https://github.com/hugsy/gef> 
  * readelf: <https://linux.die.net/man/1/readelf> 
  * objdump: <https://linux.die.net/man/1/objdump> 
  * Ubuntu 32 bit version

**Understanding the Basics**  
Before jumping into all the good stuff we need to go through some basics like what is registers, stack and assembly this will help us to understand the exploit development process better.

First, a basic understanding of assembly will be helpful to be able to make sense of all of this. In-depth coverage of assembly code is way out of scope for this article, I will leave some reference materials here, so you can go through it.

x86 Assembly Crash course is an excellent intro to assembly. <figure class="wp-block-embed-youtube wp-block-embed is-type-video is-provider-youtube wp-embed-aspect-16-9 wp-has-aspect-ratio">

<div class="wp-block-embed__wrapper">
</div></figure> 

  
**Memory Layout**<figure class="wp-block-image size-large is-resized">

![Memory-Layout](/img/6-0.jpg)


  * The&nbsp;**text**&nbsp;section stores the program executable. 
  * The&nbsp;**data**&nbsp;section stores initialized data.
  * The&nbsp;**bss&nbsp;**section stores uninitialized data.
  * The&nbsp;**heap&nbsp;**section is a memory that you can dynamically reserve from calling&nbsp;malloc. 
  * The&nbsp;**stack&nbsp;**section is a memory that functions and local variables are stored. 

#### Assembly instruction set introduced in 1978 by Intel 

  * 1978 &#8211; 16bit 
  * 1985 &#8211; 32bit 
  * 2001 &#8211; 64bit (Itanium) 
  * 2003 &#8211; 64bit (AMD64)

**Important Registers**  
A register is a location within the processor that is able to store data. For exploit development the following special-purpose registers are important.

  * **ESP:** Stack pointer, “top” of the current stack frame 
  * **EBP:** Base pointer, “bottom” of the current stack frame
  * **EIP:** Instruction pointer, a pointer to the next instruction to be executed by the CPU

**What is a Buffer Overflow?**  
A stack overflow occurs when a program stores more data in a variable on the execution stack than is allocated to the variable. The excess data corrupts nearby space in memory and may alter other data. As a result, the program might report an error or behave differently. Using unsafe functions that can lead to a buffer overflow vulnerability:&nbsp; `printf`,&nbsp;`sprintf`,&nbsp;`strcat`,&nbsp;`strcpy`, and&nbsp;`gets`. 

#### Bug Classes {#bug-classes}

There are many different possible attack vectors in today’s native binaries. I will cover some of these in this series.

  * Stack Buffer Overflows
  * Heap Buffer Overflows
  * Format String Attacks
  * Use After Free (UAF)

Now that we have some idea about binary exploitation, let’s do a simple practical example. This code is from protorstar0, the goal of this challenge is to modify the value of the &#8220;modified&#8221; variable, which is now equal to 0.<figure class="wp-block-image size-large">

<img src="https://blog.ptrace.net/wp-content/uploads/2019/12/image.png" alt="" class="wp-image-102" srcset="https://blog.ptrace.net/wp-content/uploads/2019/12/image.png 803w, https://blog.ptrace.net/wp-content/uploads/2019/12/image-300x125.png 300w, https://blog.ptrace.net/wp-content/uploads/2019/12/image-768x319.png 768w, https://blog.ptrace.net/wp-content/uploads/2019/12/image-624x260.png 624w" sizes="(max-width: 803px) 100vw, 803px" /> </figure> 

From the code we can see a **64-byte buffer**&nbsp;is in the program, we can modify it because of unsafe **gets**&nbsp;function used. The get() function allows overriding the declared buffer size.  
The **gets()** doesn’t do any array bound checking, that&#8217;s why it is considered as an unsafe function. To avoid Buffer Overflow, fgets() should be used instead of gets().

Now let&#8217;s compile the above code and open the binary in DGB. Before compiling the code, let&#8217;s disable some of the exploit mitigation mechanisms in place.  
`echo 0 | sudo tee /proc/sys/kernel/randomize_va_space` > Disable ASLR

**Compile the binary  
** compile the code using the following flags  
`gcc -fno-stack-protector -o <vuln> vuln.c`  
-fno-stack-protector :  `Emit extra code to check for buffer overflows`  
<figure class="wp-block-image size-large">

<img src="https://blog.ptrace.net/wp-content/uploads/2019/12/10.png" alt="" class="wp-image-204" srcset="https://blog.ptrace.net/wp-content/uploads/2019/12/10.png 871w, https://blog.ptrace.net/wp-content/uploads/2019/12/10-300x55.png 300w, https://blog.ptrace.net/wp-content/uploads/2019/12/10-768x140.png 768w, https://blog.ptrace.net/wp-content/uploads/2019/12/10-624x114.png 624w" sizes="(max-width: 871px) 100vw, 871px" /> </figure> 

After compiling the binary, let&#8217;s check the properties of executables, if there is any exploit mitigations (like PIE, RELRO, PaX, Canaries, ASLR ).  
<figure class="wp-block-image size-large">

<img src="https://blog.ptrace.net/wp-content/uploads/2019/12/9.png" alt="" class="wp-image-202" srcset="https://blog.ptrace.net/wp-content/uploads/2019/12/9.png 709w, https://blog.ptrace.net/wp-content/uploads/2019/12/9-300x62.png 300w, https://blog.ptrace.net/wp-content/uploads/2019/12/9-624x129.png 624w" sizes="(max-width: 709px) 100vw, 709px" /> </figure> 

Open the binary in GDB<figure class="wp-block-image size-large">

<img src="https://blog.ptrace.net/wp-content/uploads/2019/12/6.png" alt="" class="wp-image-160" srcset="https://blog.ptrace.net/wp-content/uploads/2019/12/6.png 742w, https://blog.ptrace.net/wp-content/uploads/2019/12/6-300x53.png 300w, https://blog.ptrace.net/wp-content/uploads/2019/12/6-624x111.png 624w" sizes="(max-width: 742px) 100vw, 742px" /> </figure> 

Let&#8217;s send some data to the program<figure class="wp-block-image size-large">

<img src="https://blog.ptrace.net/wp-content/uploads/2019/12/5.png" alt="" class="wp-image-141" srcset="https://blog.ptrace.net/wp-content/uploads/2019/12/5.png 838w, https://blog.ptrace.net/wp-content/uploads/2019/12/5-300x44.png 300w, https://blog.ptrace.net/wp-content/uploads/2019/12/5-768x113.png 768w, https://blog.ptrace.net/wp-content/uploads/2019/12/5-624x92.png 624w" sizes="(max-width: 838px) 100vw, 838px" /> </figure> 

We got a reply &#8220;Try Again&#8221; We know the defined buffer size is 64 bytes. Let&#8217;s send more than 64 bytes of data and monitor the program in GDB<figure class="wp-block-image size-large">

<img src="https://blog.ptrace.net/wp-content/uploads/2019/12/3.jpg" alt="" class="wp-image-117" srcset="https://blog.ptrace.net/wp-content/uploads/2019/12/3.jpg 882w, https://blog.ptrace.net/wp-content/uploads/2019/12/3-300x226.jpg 300w, https://blog.ptrace.net/wp-content/uploads/2019/12/3-768x577.jpg 768w, https://blog.ptrace.net/wp-content/uploads/2019/12/3-624x469.jpg 624w" sizes="(max-width: 882px) 100vw, 882px" /> </figure> 

As we can see from GDB output program get a segmentation fault when receiving more than 64 bytes of data. The variable &#8220;modified&#8221; get overwrite and other important registers are overwritten. 

  
This is a very simple example of how we can take advantage of vulnerable functions used in programs to exploit them. That&#8217;s it for this intro article,

<pre class="wp-block-code"><code></code></pre>
